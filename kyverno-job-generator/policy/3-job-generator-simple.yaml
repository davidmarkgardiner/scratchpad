apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: image-job-generator-simple
  annotations:
    policies.kyverno.io/title: Simple RFC-Compliant Image Job Generator
    pod-policies.kyverno.io/autogen-controllers: none
    policies.kyverno.io/category: Sample
    policies.kyverno.io/severity: medium
    policies.kyverno.io/subject: Pod
    kyverno.io/kyverno-version: 1.7.2
    policies.kyverno.io/minversion: 1.6.0
    kyverno.io/kubernetes-version: "1.23"
    policies.kyverno.io/description: >-
      Generates jobs with RFC-compliant names based on container images.
      Uses image hash for uniqueness to ensure one job per unique image.
spec:
  background: false
  rules:
    - name: generate-image-job
      match:
        any:
        - resources:
            kinds:
            - Pod
            namespaces:
            - default
            - rfc-test
            - a*
      exclude:
        any:
        - resources:
            selector:
              matchLabels:
                skip-verify: "true"
        - resources:
            namespaces:
              - kube-system
              - kyverno
      preconditions:
        any:
        - key: "{{ contains(request.object.spec.containers[0].image, 'my.registry.com') }}"
          operator: Equals
          value: true
        - key: "{{ contains(request.object.spec.containers[0].image, 'docker.io/') }}"
          operator: Equals
          value: true
      generate:
        apiVersion: batch/v1
        kind: Job
        # Use a hash of the image for uniqueness, ensuring RFC compliance
        # This guarantees one job per unique image and valid k8s names
        name: "img-job-{{ truncate(hash(request.object.spec.containers[0].image), `16`) }}"
        namespace: "{{request.namespace}}"
        synchronize: false
        data:
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: "img-job-{{ truncate(hash(request.object.spec.containers[0].image), `16`) }}"
            labels:
              skip-verify: "true"
              job-type: "image-processor"
            annotations:
              original-image: "{{ request.object.spec.containers[0].image }}"
              source-pod: "{{ request.object.metadata.name }}"
              source-namespace: "{{ request.namespace }}"
              # Create human-readable image identifier
              image-identifier: "{{ lower(replace_all('[@:/._]', '-', request.object.spec.containers[0].image)) }}"
          spec:
            template:
              metadata:
                labels:
                  skip-verify: "true"
                  job-type: "image-processor"
              spec:
                containers:
                - name: process-image
                  image: mcr.microsoft.com/azure-cli
                  env:
                  - name: POD_NAME
                    value: "{{ request.object.metadata.name }}"
                  - name: POD_NAMESPACE
                    value: "{{ request.namespace }}"
                  - name: ORIGINAL_IMAGE
                    value: "{{ request.object.spec.containers[0].image }}"
                  - name: IMAGE_HASH
                    value: "{{ truncate(hash(request.object.spec.containers[0].image), `16`) }}"
                  command:
                  - /bin/bash
                  - -c
                  - |
                    echo "========================================="
                    echo "Image Processing Job"
                    echo "========================================="
                    echo "Job Name: img-job-$IMAGE_HASH"
                    echo "Image Hash: $IMAGE_HASH"
                    echo "Original Image: $ORIGINAL_IMAGE"
                    echo "Source Pod: $POD_NAME"
                    echo "Source Namespace: $POD_NAMESPACE"
                    echo ""
                    
                    # Parse image components
                    IMAGE_FULL="$ORIGINAL_IMAGE"
                    
                    # Handle image with digest
                    if [[ "$IMAGE_FULL" == *"@sha256:"* ]]; then
                      IMAGE_BASE="${IMAGE_FULL%%@*}"
                      IMAGE_DIGEST="${IMAGE_FULL#*@}"
                      echo "Image has digest: $IMAGE_DIGEST"
                    else
                      IMAGE_BASE="$IMAGE_FULL"
                      IMAGE_DIGEST=""
                    fi
                    
                    # Handle image with tag
                    if [[ "$IMAGE_BASE" == *":"* ]]; then
                      IMAGE_NAME="${IMAGE_BASE%%:*}"
                      IMAGE_TAG="${IMAGE_BASE#*:}"
                    else
                      IMAGE_NAME="$IMAGE_BASE"
                      IMAGE_TAG="latest"
                    fi
                    
                    # Extract registry
                    if [[ "$IMAGE_NAME" == *"/"* ]]; then
                      REGISTRY="${IMAGE_NAME%%/*}"
                      IMAGE_PATH="${IMAGE_NAME#*/}"
                    else
                      REGISTRY="docker.io"
                      IMAGE_PATH="library/$IMAGE_NAME"
                    fi
                    
                    echo "Parsed Image Components:"
                    echo "  Registry: $REGISTRY"
                    echo "  Image Path: $IMAGE_PATH"
                    echo "  Tag: $IMAGE_TAG"
                    [[ -n "$IMAGE_DIGEST" ]] && echo "  Digest: $IMAGE_DIGEST"
                    echo ""
                    
                    # Process based on registry
                    if [[ "$REGISTRY" == "docker.io" ]]; then
                      NEW_REGISTRY="my.registry.com"
                      NEW_IMAGE="$NEW_REGISTRY/$IMAGE_PATH:$IMAGE_TAG"
                      echo "Action: Mirror docker.io image to $NEW_REGISTRY"
                      echo "Target: $NEW_IMAGE"
                      
                      # Here you would add actual image mirroring logic
                      # Example:
                      # docker pull $ORIGINAL_IMAGE
                      # docker tag $ORIGINAL_IMAGE $NEW_IMAGE
                      # docker push $NEW_IMAGE
                    elif [[ "$REGISTRY" == "my.registry.com"* ]]; then
                      echo "Action: Process existing registry image"
                      echo "Image already in target registry"
                    else
                      echo "Action: Handle third-party registry"
                      echo "Registry: $REGISTRY"
                    fi
                    
                    echo ""
                    echo "Job completed successfully"
                    echo "========================================="
                    
                    # Short sleep to allow log collection
                    sleep 10
                restartPolicy: Never
            backoffLimit: 3
            ttlSecondsAfterFinished: 3600  # Clean up completed jobs after 1 hour